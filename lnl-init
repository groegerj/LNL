#!/system/bin/sh

# /system/xbin/lnl-init -- initialise directories etc., called by lnl
#
# Copyright (C) 2014-2017 Josua Groeger.
#
# LNL stands for "LNL not Linux". It consists of several shell scripts
# to establish a chroot Debian-Linux environment on an Android system.
#
#
# LICENSE
#
# LNL is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# LNL is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with LNL.  If not, see <http://www.gnu.org/licenses/>.

if [[ $(id -u) -ne 0 ]]; then
  echo "lnl-init must be run as root, exiting."
  exit 1
fi

debian_dirs=(bin opt root sbin usr etc lib srv var)
android_dirs=(dev proc sys data system mnt storage) # essential ones...

home_dir=/data/media/home
sdcard_source=/data/media/0
sdcard_targets=(/sdcard /home/sdcard)

debian_root=/debian
android_root=/android
debian_system=/data/debian

# Android toybox does not know recursive binds...
mountcommand="busybox mount"

if [[ -d "$debian_root" ]]; then
  exit 0
fi

# busybox must be installed for this to work
type busybox >/dev/null 2>&1 ||
  { echo >&2 "busybox not installed, exiting."; exit 1; }

# -------------------------------------------------------------------
# security related stuff
# -------------------------------------------------------------------

# set SE Linux to permissive,
# seems to be necessary for cryptsetup to work on Android 6
# moreover, allows for transparent mounting
setenforce 0

iptables_allow_port_local() {
  iptables -C INPUT --src 127.0.0.1 -i lo -p tcp --dport $1 -j ACCEPT ||
  iptables -A INPUT --src 127.0.0.1 -i lo -p tcp --dport $1 -j ACCEPT
}

iptables_block_port() {
  iptables -C INPUT -p udp --dport $1 -j DROP ||
  iptables -A INPUT -p udp --dport $1 -j DROP
  iptables -C INPUT -p tcp --dport $1 -j DROP ||
  iptables -A INPUT -p tcp --dport $1 -j DROP
}

# x11
iptables_block_port 6000
iptables_block_port 6001

# -------------------------------------------------------------------
# build tmpfs directory tree
# -------------------------------------------------------------------

$mountcommand -o remount,rw /
mkdir -m 755 "$debian_root"
mkdir -m 755 "$debian_root/${android_root#/}"

# clone the whole android root
for i in /*; do
  if [[ "${i#/}" != "${debian_root#/}" ]]; then
    if [[ -h "$i" || -f "$i" || $(stat -c '%d' "$i") == 1 ]]; then
      # copy files and links and anything on tmpfs (bind-mount fails there)
      cp -al "$i" "$debian_root/${android_root#/}/${i#/}"
    elif [[ -d "$i" ]]; then
      # recursive bind-mount all other non-tmpfs directories
      mkdir "$debian_root/${android_root#/}/${i#/}"
      $mountcommand --rbind "$i" "$debian_root/${android_root#/}/${i#/}"
    else
      echo "Error: don't know how to handle \"$i\"..."
    fi
  fi
done

mkdir -m 777 "$debian_root/tmp"
mkdir -m 755 "$debian_root/run"

for i in ${android_dirs[*]}; do
  mkdir "$debian_root/$i"
  if [[ "$i" == "sys" ]]; then
    # bind mount, not recursive here,
    # because /sys/fs/selinux filesystem somehow breaks apt-get, dpkg, X11...
    $mountcommand --bind "/$i" "$debian_root/$i"
  else
    $mountcommand --rbind "/$i" "$debian_root/$i"
  fi
done

for i in ${debian_dirs[*]}; do
  mkdir "$debian_root/$i"
  $mountcommand --rbind "$debian_system/$i" "$debian_root/$i"
done

# home directory
mkdir -m 755 "$debian_root/home"

if [[ ! -d "$home_dir" ]]; then
  mkdir -m 755 "$home_dir"
  chown media_rw:media_rw "$home_dir"
fi
$mountcommand --rbind "$home_dir" "$debian_root/home"

for i in ${sdcard_targets[*]}; do
  if [[ ! -d "$debian_root/${i#/}" ]]; then
    mkdir "$debian_root/${i#/}"
  fi
  $mountcommand --rbind "$sdcard_source" "$debian_root/${i#/}"
done

# Strange, the android system seems not to have loop device files by default
for i in 0 1 2 3 4 5 6 7
do
  if [[ ! -e /dev/loop$i ]]; then
    mknod /dev/loop$i b 7 $i
  fi
done

